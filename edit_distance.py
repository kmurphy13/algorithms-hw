# Kira Murphy
# CS362 HW

def edit_distance(s:str, t:str) -> int:
    def distance(i:int, j:int) -> int:
        if i == 0: return j  # distance(0, j) = j
        if j == 0: return i  # distance(i, 0) = i

        return min(
            1 + distance(i - 1, j - 1) if s[i-1] != t[j-1]
                                       else distance(i-1, j-1),
            1 + distance(i-1, j),  # delete
            1 + distance(i, j-1)   # insert
        )
    return distance(len(s), len(t))

from typing import List, Tuple


def edit_distance_dp(s: str, t: str) -> List[List[int]]:
    dist = [[0] * (len(t) + 1) for _ in range(len(s)+1)]

    # fill in top row
    for j in range(len(t)+1): dist[0][j] = j

    # fill in left column
    for i in range(len(s)+1): dist[i][0] = i

    for i in range(1, len(s)+1):
        for j in range(1, len(t)+1):
            dist[i][j] = \
            min(
                    1 + dist[i - 1][j - 1] if s[i-1] != t[j-1]
                                           else dist[i-1][j-1],
                    1 + dist[i-1][j],  # delete
                    1 + dist[i][j-1]   # insert
                )

    return dist

def align(s: str, t:str) -> Tuple[str, str, str]:

     def align(i: int, j: int, sa:str, ta : str, changes:str) -> Tuple[str,str,str]:

        # If either i or j are 0, these are our base cases
        if i == 0 or j == 0:
            # If they are both 0 then the words are the same length so we can just return
            if i == 0 and j == 0:
                return sa, ta, changes
            # If i is 0, then there letters remaining in t that haven't been added to ta
            # so add these letters and pad sa
            elif i == 0  and j > 0:
                ta = t[:j] + ta
                sa = "-"*j + sa
                changes = " "*j + changes
                return sa, ta, changes
            # Opposite of above case
            else:
                ta = "-"*i + ta
                sa = s[:i] + sa
                changes = " "*i + changes
                return sa,ta, changes

        # Calculate the minimum to see how we arrived at the current square
        minimum = min(dist[i - 1][j - 1], dist[i - 1][j], dist[i][j - 1])

        # If the minimum is on the diagonal, we either have a mutation or no change
        if minimum == dist[i-1][j-1]:
            # If the minimum isn't the current square, then there must be a change
            if minimum != dist[i][j]:
                sa = s[i - 1] + sa
                ta = t[j - 1] + ta
                changes = "*" + changes
            # Otherwise, there was no change and we pad changes
            else:
                sa = s[i - 1] + sa
                ta = t[j - 1] + ta
                changes = " " + changes
            return align(i-1, j-1, sa, ta, changes)
        # Insertion
        elif minimum == dist[i-1][j]:
            # Pad changes
            changes = " " + changes
            # Add letter to sa
            sa = s[i-1] + sa
            # Insert a dash in ta
            ta = "-" + ta
            return align(i-1, j, sa, ta, changes)
        # Deletion
        else:
            # Pad changes
            changes = " " + changes
            # Add dash to sa
            sa = "-" + sa
            # Add letter to ta
            ta = t[j-1] + ta
            return align(i, j-1, sa, ta, changes)

     # Get the matrix generated by the edit distance table
     dist = edit_distance_dp(s, t)

     # Call our helper function
     return align(len(s), len(t), "", "", "")



if __name__ == "__main__":
    lst = align("hipopotomoose", "hippopotamus")
    print(lst[0])
    print(lst[1])
    print(lst[2])

    lst = align("snowy", "sunny")
    print(lst[0])
    print(lst[1])
    print(lst[2])

    lst = align("repeal", "treat")
    print(lst[0])
    print(lst[1])
    print(lst[2])

    lst = align("exponential", "polynomial")
    print(lst[0])
    print(lst[1])
    print(lst[2])

